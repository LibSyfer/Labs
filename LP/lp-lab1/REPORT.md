# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Козлов А. Д.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Список в прологе - упорядоченная последовательность элементов, которая может иметь произвольную длину, причем порядок элементов в последовательности является существенным; при работе со списками не указывается конкретный тип данных внутри него, однако необходимо, чтобы все элементы списка имели единый тип - элементами списка могут быть любые термы – константы, переменные, структуры (те же списки). 

Списки похожи на такие традиционные структуры данных, как массив, вектор и, естественно, они похожи на списки, реализуемые в императивных языках программирования. Однако списки в языке Пролог все же имеют отличия от привычных подходов хранения данных в других языках: список в Прологе не требует декларирования размера и типа данных его элементов до начала использования; кроме того, Пролог способен обособлять первый элемент списка (голову) и все остальные элементы (хвост).

## Задание 1.1: Предикат обработки списка

nth(N,[H|T],X) - предикат обработки списка, получающий N элемент из списка [H|T] и записывающий его в переменную X (нумерование с 0 индекса). Построен на рекурсии: для N = 0 X - голова списка, а для остальных N происходит отсечение головы и уменьшение N на 1, что в итоге даст предикат с N = 0.

nth1(N,[H|T],X) - тот же самый предикат, но построенный при помощи стандартных предикатов length и append: при помощи length создается список из N элементов и при помощи append возращаются два списка, разделяющих список [H|T] в позиции N - 1; следовательно элемент N - голова второго разделяющего списка.

Примеры использования:
```prolog
?- nth(0,[3434,67,2,0],X).
X = 3434.
?- nth(4,[0,0,342,2342,54754,777,90],X).
X = 54754.
?- nth1(4,[0,0,342,2342,54754,777,90],X).
X = 54754.
?- nth(4,[0,0,342,2342,54754,777,90],54754).
true.
```

Реализация:
```prolog
nth(0,[H|T],H) :- !.
nth(N,[H|T],X) :-
    N1 is N - 1,
    nth(N1,T,X).

nth1(N,[H|T],X) :-
    length(L1, N),
    append(L1, [H1|T1], [H|T]),
    X is H1.
```

## Задание 1.2: Предикат обработки числового списка

gp_check([H|T]) - предикат проверки списка на геометрическую последовательность. Предикат проверяет список на пустоту, проверяет неравенство 0 первого элемента, вычисляет знаменатель прогрессии R при помощи предиката ratio([H|T],R) , проверяет его на неравенство 0, затем рекурсивно вызывается предикат ratio_check(R,[H|T]) для проверки равенства знаменателя прогресии R для каждой пары элементов в списке.

Примеры использования:
```prolog
?- gp_check([1,2,3,4,5]).
false.
?- gp_check([1,1,1,1,1,1,1,1]).
true.
?- gp_check([1,0,1]).
false.
?- gp_check([1,3,9,27,81]).
true.
?- gp_check([1,-2,4,-8,16]).
true.
```

Реализация:
```prolog
gp_check([H|T]) :-
    not(length(T,0)),
    not(H = 0),
    ratio([H|T],R),
    not(R = 0),
    ratio_check(R,[H|T]),
    !.

ratio([H|T],R) :-
    nth(1,[H|T],X),
    R is X / H.

ratio_check(R,[LastElem]) :- !.
ratio_check(R,[H|T]) :-
    nth(1,[H|T],X),
    R1 is X / H,
    R1 = R,
    ratio_check(R,T),
    !.
```

## Задание 2: Реляционное представление данных

Преимущества реляционного представления заключается в удобном поиске необходимой информации, такое представление отображает информацию в наиболее простой для пользователя форме, позволяет легко добавлять новую и удалять ненужную информацию. Однако есть и недостатки: довольно медленный доступ к данным (он удобен с точки зрения понимания места поиска, но иногда занимает много времени), а также возможные трудности, возникающие при работе с огромными размерами информации (слишком большие таблицы).
В частности, мое представление данных не совсем удобно, так как записей очень много, и к тому же искать определенную информацию является затруднительным (например, чтобы посмотреть оценки студентов определенной группы, нужно помнить, к какой группе принадлежит студент, ведь факт grade не отображает этой информации).

В первом пункте требуется получить таблицу групп и средний балл по каждой из групп:
Я реализовал предикат group(Group,L), который при помощи стандартного предиката findall ищет в базе данных нужные записи и записывает всех студентов группы в отдельный список. Также я реализовал предикат group_table([Group|T]), который принимает список номеров групп и также при помощи findall находит всех студентов для каждой группы, однако теперь при помощи стандартного предикакта asserta в базу данных добавляется факт group(Group,L), а пользователю выводятся номера всех групп и соответствующие списки студентов.
Для нахождения среднего балла по группе я реализовал предикат avg_grade(Group,N), который при помощи bagof (тот же findall, но при пустом списке выдает неуспех) ищет в базе данных количество получений каждой оценки в группе - делается это при помощи предиката gradeN_student(N,Name,Group); затем на основе полученных данных вычисляется сумма баллов (длина каждого списка, умноженная на значение оценки) и делится на общее количество оценок (сумма длин всех списков с оценками). Этот результат и будет средним баллом группы.

Во втором пункте требуется для каждого предмета получить список студентов, не сдавших экзамен. Делается это легко при помощи единственного предиката notpassed_list(Subject,L), который использует bagof для нахождения имен студентов, для которых имеется факт получения двойки по данному предмету grade(X,Subject,2).

В третьем пункте требуется найти количество не сдавших студентов в каждой из групп. Для этого реализован предикат n_of_notpassed(Group,N), который при помощи предиката setof (в отличии от findall и bagof получает отсортированный список без повторений элементов) получает список студентов, удовлетворяющих предикату notpassed_student(Name,Group), то есть получивших двойку и находящихся в данной группе, а затем вычисляет длину этого списка, что и является ответом.

## Выводы

Данная лабораторная работа научила меня работать со списками в языке Пролог (я понял, что основной прицип работы состоит в отделении головы списка и рекурсивном вызове для хвоста). Также я понял, что основным принципом работы в Прологе является рекурсия, строящая дерево, которое испольуется для поиска решений. Я стал более понимать принципы декларативного программирования, которое описывает, что представляет собой проблема и ожидаемый результат, в отличии от императивного, которое описывает как решить задачу и представить результат; это заставило меня задуматься, какая парадигма более удобна для прикладного программиста и для каких задач можно использовать тот или иной язык: с одной стороны, императивные языки проще для понимания, порог вхождения в них меньше, и возможности, возможно, шире, но с другой стороны декларативный язык позволяет писать простой, элегантный код, а также позволяет находить намного более простые решения для задач по сравнению с решениями, использующих императивные языки...
Работа была интересной и не совсем сложной, надеюсь данные знания пригодятся мне в будущем.
